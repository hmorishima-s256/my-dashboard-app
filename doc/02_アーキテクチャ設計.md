# 02. アーキテクチャ設計

## 2.1 設計方針（UNIX 哲学ベース）

- 1つのモジュールは1つの責務に集中する
- モジュール同士は小さく明確な契約で接続する
- 画面ロジック、I/O、永続化、IPC を分離する
- 共有契約型を単一ファイルで管理し、型の重複を避ける

## 2.2 プロセス構成

### Main Process (`src/main`)

- `index.ts`
  - Composition Root
  - 依存注入、ライフサイクル接続、状態保持
- `ipc/registerMainIpcHandlers.ts`
  - IPC ハンドラ登録専用
- `services/calendarPublisher.ts`
  - 予定取得結果の配信専用
- `services/autoFetchScheduler.ts`
  - 自動取得判定専用
- `services/autoLaunch.ts`
  - Windows 初回自動起動設定専用
- `googleAuth.ts`
  - Google OAuth、プロフィール取得、カレンダー取得、トークン保存
- `appSettings.ts`
  - ユーザー別設定の読み書きと正規化

### Preload (`src/preload`)

- `window.api` を公開するブリッジ層
- Renderer からの入口を型付きで制限

### Renderer (`src/renderer/src`)

- `App.tsx`
  - 画面オーケストレーション
- `components/*`
  - 表示責務のみ
- `hooks/useDateEditor.ts`
  - 年月日入力の状態遷移と検証
- `lib/*`
  - 純粋関数ユーティリティ
- `types/ui.ts`
  - UI 固有型と shared 契約型の再エクスポート

### Shared (`src/shared`)

- `contracts.ts`
  - Main/Preload/Renderer 共通の型契約

## 2.3 状態管理

- Main 側共有状態
  - `currentUser`
  - `settings`
  - `lastAutoFetchDateKey`
  - `lastIntervalFetchAtMs`
- Renderer 側 UI 状態
  - 表示対象日、テーブル行、モーダル開閉、認証 UI 状態など

## 2.4 データフロー

1. Renderer が `window.api` を呼ぶ
2. Preload が IPC で Main に転送
3. Main がサービス/ドメインを実行
4. 必要に応じて `calendar-updated` を Renderer へ push

## 2.5 主要フロー

### 起動

1. `ensureSharedFiles` で `_shared` を準備
2. `getSavedUserProfile` で保存済みログイン状態を復元
3. `loadAppSettings` で現在ユーザー設定を反映
4. `applyWindowsAutoLaunchSetting` を初回のみ適用
5. Tray 作成
6. `autoFetchScheduler.start()`
7. `registerMainIpcHandlers(...)`
8. Window 作成

### ログイン

1. Renderer: `authLogin()`
2. Main: ローカル HTTP サーバで OAuth 認可
3. 認可成功後:
   - `userinfo.get()` でプロフィール取得
   - `current-user.json` / `user-profile.json` / `token.json` 保存
4. Main: ウィンドウ前面化
5. Main: 当日予定を取得して通知

### 予定取得

1. Renderer: `getCalendar(targetDate)`
2. Main: `calendarPublisher.fetchAndPublishByDate`
3. Main: `googleAuth.getEventsByDate`
   - `calendarList.list` 取得
   - 各カレンダーの `events.list` を並列取得（同時実行数制限あり）
   - 429/5xx/ネットワーク系は指数バックオフでリトライ
4. Renderer: 戻り値と通知でテーブル更新

### 自動取得

1. 30秒ごとに判定
2. 条件:
   - 指定時刻に達した（1日1回）
   - 指定間隔が経過した
3. 実行時は当日を `source: 'auto'` として配信

## 2.6 セキュリティ境界

- Renderer は Node API へ直接アクセスしない
- 認証情報は Main 側のみで扱う
- `token.json` は `safeStorage` 利用可能時に暗号化保存
- 外部 URL は `shell.openExternal` 経由で開く
