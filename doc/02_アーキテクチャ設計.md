# 02. アーキテクチャ設計

## 2.1 設計方針（UNIX哲学ベース）

- 1つのモジュールは1つの責務を持つ
- 複雑さは合成で作り、部品は小さく保つ
- I/OとUIロジックを分離する
- 契約を型で固定する

## 2.2 この方針にした理由（設計意図）

- 機能追加時に既存を壊しにくくするため
- テスト対象を小さくして検証しやすくするため
- 認証情報をRendererから隔離し、セキュリティ境界を明確にするため

## 2.3 プロセス構成

### Main Process (`src/main`)

- `index.ts`
  - Composition Root。依存注入とアプリライフサイクル接続を担当
- `ipc/registerMainIpcHandlers.ts`
  - IPC登録の合成
- `ipc/handlers/*.ts`
  - calendar/settings/task/auth の機能別ハンドラ
- `services/calendarPublisher.ts`
  - 予定取得結果の通知配信
- `services/autoFetchScheduler.ts`
  - 自動取得判定ループ
- `services/autoLaunch.ts`
  - Windows自動起動の初回設定
- `services/taskStore.ts`
  - lowdbによるタスク保存
- `googleAuth.ts`
  - OAuth、ユーザー情報、カレンダー取得
- `appSettings.ts`
  - 設定読込/保存と値正規化

### Preload (`src/preload`)

- `window.api` 経由でRendererに限定APIを公開

### Renderer (`src/renderer/src`)

- `App.tsx`: 画面全体の合成
- `components/*`: 表示責務
- `hooks/*`: 状態管理とユースケース
- `lib/*`: 純粋関数ユーティリティ

### Shared (`src/shared/contracts.ts`)

- 共通契約型を一元管理

## 2.4 状態管理

- Main側
  - `currentUser`
  - `settings`
  - 自動取得の実行済み状態
- Renderer側
  - 認証UI状態
  - 日付選択状態
  - 設定モーダル状態
  - 予定行・タスク行状態

## 2.5 主要データフロー

1. Renderer が `window.api` を呼ぶ
2. Preload が IPC で Main へ委譲
3. Main がサービスを実行
4. 必要に応じて `calendar-updated` を push 通知

## 2.6 主要フロー

### 起動

1. 共通ファイル準備（`_shared`）
2. 保存済みユーザー復元
3. ユーザー設定読込
4. Windows自動起動の初回適用判定
5. トレイ作成
6. 自動取得スケジューラ開始
7. IPC登録
8. ウィンドウ作成

### ログイン

1. ローカルHTTPコールバックでOAuth認証
2. `userinfo.get()` でプロフィール取得
3. `current-user.json` / `user-profile.json` / `token.json` 保存
4. 設定再読込
5. 当日予定を自動同期

### タスク操作

1. Rendererから `task:*` IPC呼び出し
2. Mainの `taskStore` が userId を現在ユーザーから解決
3. `tasks.json` へ保存
4. Renderer側で画面状態を更新

## 2.7 セキュリティ境界

- RendererはNode APIへ直接アクセスしない
- 認証情報はMainだけで扱う
- `token.json` は `safeStorage` 利用可能時に暗号化
- 外部URL遷移は `shell.openExternal` 限定
