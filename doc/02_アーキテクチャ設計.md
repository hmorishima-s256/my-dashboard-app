# 02. アーキテクチャ設計

## 2.1 プロセス構成

### Main Process (`src/main`)

- アプリライフサイクル管理
- IPC ハンドラ提供
- Google OAuth 実行
- Google Calendar API 呼び出し
- ローカルファイル読み書き
- 自動取得スケジューラ
- トレイ常駐/終了制御
- Windows 自動起動設定

### Preload (`src/preload`)

- `contextBridge` で `window.api` を公開
- Renderer が直接 Node API に触れないよう制御
- IPC の型付き窓口

### Renderer (`src/renderer`)

- 画面描画
- 入力バリデーション（UI レベル）
- `window.api` 経由で Main と通信
- 更新通知 (`calendar-updated`) の購読

## 2.2 レイヤ責務

- UI 責務: `App.tsx` と `main.css`
- ドメイン/API 呼び出し責務: `googleAuth.ts`
- 設定永続化責務: `appSettings.ts`
- プロセス接続責務: `preload/index.ts`

## 2.3 主な処理フロー

### 起動フロー

1. Main 起動
2. `_shared` の共通ファイル作成 (`ensureSharedFiles`)
3. `current-user.json` + `token.json` からログイン状態復元
4. ユーザー別設定の読み込み
5. トレイ作成
6. 自動取得スケジューラ開始
7. Renderer ウィンドウ生成

### ログインフロー

1. Renderer が `auth:login` 呼び出し
2. Main がローカル HTTP サーバを立て OAuth 認可開始
3. ブラウザで Google 認証/同意
4. コールバックで token 取得
5. ユーザー情報取得 (`userinfo.get`)
6. `current-user.json` / `user-profile.json` / `token.json` 保存
7. Main が Renderer へ復帰、当日予定を自動取得

### 予定取得フロー（手動）

1. Renderer で「同期」または日付変更
2. `get-calendar(targetDate)` 呼び出し
3. Main が `getEventsByDate` 実行
4. 全カレンダーから予定集約
5. Renderer に戻り値返却 + `calendar-updated` 通知

### 自動取得フロー（バックグラウンド）

1. 30 秒ごとにスケジューラ判定
2. 指定時刻到達または指定間隔経過で取得
3. Main で予定取得
4. ウィンドウが存在すれば `calendar-updated` 通知

## 2.4 設計上のポイント

- ユーザー依存設定と共通設定をファイル分離
- ログアウト時は `token.json` のみ削除し、設定/プロファイルは維持
- UI 表示中の日付が「今日以外」のときは自動通知で上書きしない
- ウィンドウ close 時に「常駐 or 終了」を明示選択

## 2.5 セキュリティ境界

- Renderer からの権限操作は `window.api` のみに限定
- BrowserWindow 側は `webPreferences.preload` 経由
- 外部 URL の `window.open` は `shell.openExternal` で分離
